<!DOCTYPE html>
<meta charset="utf-8">
<head>
    <style>

        body {
        background: #fcfcfa;
        height: 500px;
        position: relative;
        width: 960px;
        }

        .stroke {
        fill: none;
        stroke: #000;
        stroke-width: 3px;
        }

        .fill {
        fill: #fff;
        }

        .graticule {
        fill: none;
        stroke: #777;
        stroke-width: .5px;
        stroke-opacity: .5;
        }

        .land {
        fill: #222;
        }

        .boundary {
        fill: none;
        stroke: #fff;
        stroke-width: .5px;
        }

        @font-face {
            font-family: 'AquilineTwoRegular';
            src: url('AquilineTwo-webfont.eot');
            src: url('AquilineTwo-webfont.eot?#iefix') format('embedded-opentype'),
                 url('AquilineTwo-webfont.woff') format('woff'),
                 url('AquilineTwo-webfont.ttf') format('truetype'),
                 url('AquilineTwo-webfont.svg#AquilineTwoRegular') format('svg');
            font-weight: normal;
            font-style: normal;
        }

        #projection-menu {
        position: absolute;
        right: 10px;
        top: 10px;
        }

    </style>

    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://d3js.org/d3-geo-projection.v1.min.js"></script>
    <script src="https://d3js.org/topojson.v2.min.js"></script>
</head>

<body></body>

<!-- ***** MODIF MATHIS ***** -->
<select id="projections-menu"></select>
<!-- ***** ***** ****** ***** -->

<script>

/***** MODIF MATHIS *****/
var options = [
    { name: "Natural Earth",
      projection: d3.geoNaturalEarth()
                   .scale(175)
                   .translate([width / 2, height / 2])
                   .precision(.1) },
    { name: "Aitoff",
      projection: d3.geoAitoff() }
] ;

var menu = d3.select ("#projections-menu")
    .on ("change", change) ;

menu.selectAll ("option")
    .data (options)
    .enter ().append ("option")
    .text (function (d) { return d.name ; }) ;

function change() {
  clearInterval(interval);
  update(options[this.selectedIndex]);
}

function update(option) {
  svg.selectAll("path").transition()
      .duration(750)
      .attrTween("d", projectionTween(projection,
				      projection = option.projection));
    projection = "toto" ;
}
/***** **** ****** *****/

var width = 960,
    height = 500;

var projection = d3.geoNaturalEarth()
                   .scale(175)
                   .translate([width / 2, height / 2])
                   .precision(.1);

var path = d3.geoPath()
             .projection(projection);

var graticule = d3.geoGraticule();

var svg = d3.select("body").append("svg")
            .attr("width", width)
            .attr("height", height);

svg.append("defs").append("path")
                  .datum({type: "Sphere"})
                  .attr("id", "sphere")
                  .attr("d", path);

svg.append("use")
   .attr("class", "stroke")
   .attr("xlink:href", "#sphere");

svg.append("use")
   .attr("class", "fill")
   .attr("xlink:href", "#sphere");

svg.append("path")
   .datum(graticule)
   .attr("class", "graticule")
   .attr("d", path);

var data;
var road;
var nb_element;
var projections = [];

function sqr(a) {
    return a*a;
}

function circles(){
    nb_element = data.length;
    road = svg.selectAll(".pin")
              .data(data).enter()
              .append("circle", ".pin")
              .attr("r", 1)
              .attr("transform", function(d) {

                    projections.push(projection([
                        d.longitude,
                        d.latitude
                    ]));
                    return "translate(" + projection([
                        d.longitude,
                        d.latitude
                    ]) + ")"
                })
              .attr ("fill", "red")
              .attr("opacity", 0);

    animation();

    function animation(){
        /*road.transition()
            .delay(function(d,i){return 10 * i; }) 
            .duration(250)
            .attr("opacity", 1)
            .transition()
            .delay(function(d,i){return (10 * ((nb_element -1) - i) + 1000);})
            .attr("opacity", 0)
            .on("end", function(d, i){
                if(i == (nb_element - 1)){
                    animation()
                }
                ;});*/

        svg.selectAll("line")
            .data(projections).enter()
            .append("line")
            .attr("x1", function(d, i){
                return projections[i][0];
            })
            .attr("y1", function(d, i){
                return projections[i][1];
            })
            .attr("x2", function(d, i){
                return projections[i][0];
            })
            .attr("y2", function(d, i){
                return projections[i][1];
            })
            .attr("stroke", "blue")
            .attr("stroke-width", 1)
            .transition()
            .delay(function(d,i){return 10 * i;}) 
            .duration(250)
            .attr("x2", function(d, i){
                if(i == (nb_element - 1)){
                    return projections[i][0];
                }
                else{
                    euclidian = Math.sqrt(sqr(projections[(i+1)][1] - projections[i][1]) + sqr(projections[(i+1)][0] - projections[i][0]));
                    console.log("euclidian", euclidian)
                    if(euclidian < 20){
                        return projections[(i + 1)][0];
                    }
                    else{
                        return projections[i][0];                        
                    }
                }
            })
            .attr("y2", function(d, i){
                if(i == (nb_element - 1)){
                    return projections[i][1];
                }
                else{
                    euclidian = Math.sqrt(sqr(projections[(i+1)][1] - projections[i][1]) + sqr(projections[(i+1)][0] - projections[i][0]));
                    console.log("euclidian", euclidian)
                    if(euclidian < 20){
                        return projections[(i + 1)][1];
                    }
                    else{
                        return projections[i][1];                        
                    }
                }
            })
            .transition()
            .delay(function(d,i){return (10 * ((nb_element -1) - i) + 1000);})
            .remove()
            .on("end", function(d, i){
                if(i == (nb_element - 1)){
                    animation()
                }
                ;});
    }

}



d3.json("https://gist.githubusercontent.com/mbostock/4090846/raw/d534aba169207548a8a3d670c9c2cc719ff05c47/world-110m.json", function(error, world) {
  if (error) throw error;

  svg.insert("path", ".graticule")
     .datum(topojson.feature(world, world.objects.land))
     .attr("class", "land")
     .attr("d", path);
});

d3.csv("https://gist.githubusercontent.com/Hakkahi/198a39ea6e58125168c2125be88ae02d/raw/2b3fa382eacf2e6bbd60ffea32a65623c3210513/data.csv", function(rawData) {
    data = rawData
    nb_element = data.length
    circles()
});

</script>
